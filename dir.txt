Skip to content
Chat history

You said:
directory related system calls
ChatGPT said:
Hereâ€™s a clear and complete explanation of directory-related system calls in UNIX/Linux, along with their syntax, description, and simple C programs to demonstrate their usage ğŸ‘‡

ğŸ—‚ï¸ Directory-Related System Calls in UNIX
These system calls are used to create, remove, open, read, and change directories in UNIX/Linux.

1. mkdir() â€“ Create a Directory
Header:

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
Syntax:

int mkdir(const char *pathname, mode_t mode);
Description:
Creates a new directory with the specified name and permission.

Example:

#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

int main() {
    if (mkdir("mydir", 0777) == 0)
        printf("Directory created successfully.\n");
    else
        perror("mkdir");
    return 0;
}
2. rmdir() â€“ Remove a Directory
Header:

#include <unistd.h>
Syntax:

int rmdir(const char *pathname);
Description:
Removes an empty directory.

Example:

#include <stdio.h>
#include <unistd.h>

int main() {
    if (rmdir("mydir") == 0)
        printf("Directory removed successfully.\n");
    else
        perror("rmdir");
    return 0;
}
3. chdir() â€“ Change Current Working Directory
Header:

#include <unistd.h>
Syntax:

int chdir(const char *path);
Description:
Changes the current working directory of the calling process.

Example:

#include <stdio.h>
#include <unistd.h>

int main() {
    if (chdir("/home") == 0)
        printf("Changed directory to /home\n");
    else
        perror("chdir");
    return 0;
}
4. getcwd() â€“ Get Current Working Directory
Header:

#include <unistd.h>
Syntax:

char *getcwd(char *buf, size_t size);
Description:
Retrieves the absolute pathname of the current working directory.

Example:

#include <stdio.h>
#include <unistd.h>

int main() {
    char path[1024];
    if (getcwd(path, sizeof(path)) != NULL)
        printf("Current directory: %s\n", path);
    else
        perror("getcwd");
    return 0;
}
5. opendir() â€“ Open a Directory Stream
Header:

#include <dirent.h>
Syntax:

DIR *opendir(const char *name);
Description:
Opens a directory stream corresponding to the directory name.

Example:

#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *d = opendir(".");
    if (d)
        printf("Directory opened successfully.\n");
    else
        perror("opendir");
    closedir(d);
    return 0;
}
6. readdir() â€“ Read Directory Entries
Header:

#include <dirent.h>
Syntax:

struct dirent *readdir(DIR *dirp);
Description:
Reads entries in a directory stream (like file names).

Example:

#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *d;
    struct dirent *dir;
    d = opendir(".");
    if (d) {
        while ((dir = readdir(d)) != NULL)
            printf("%s\n", dir->d_name);
        closedir(d);
    } else {
        perror("opendir");
    }
    return 0;
}
7. closedir() â€“ Close Directory Stream
Header:

#include <dirent.h>
Syntax:

int closedir(DIR *dirp);
Description:
Closes the directory stream opened by opendir().

Used With:
opendir() and readdir() (as shown above).

8. rewinddir() â€“ Reset Directory Stream
Header:

#include <dirent.h>
Syntax:

void rewinddir(DIR *dirp);
Description:
Resets the position of the directory stream to the beginning.

Example:

#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *d = opendir(".");
    struct dirent *dir;

    printf("First read:\n");
    while ((dir = readdir(d)) != NULL)
        printf("%s\n", dir->d_name);

    rewinddir(d);  // Reset pointer
    printf("\nAfter rewind:\n");
    while ((dir = readdir(d)) != NULL)
        printf("%s\n", dir->d_name);

    closedir(d);
    return 0;
}
ğŸ“˜ Summary Table
System Call	Purpose	Header File
mkdir()	Create a new directory	<sys/stat.h>
rmdir()	Remove a directory	<unistd.h>
chdir()	Change working directory	<unistd.h>
getcwd()	Get current working directory	<unistd.h>
opendir()	Open a directory stream	<dirent.h>
readdir()	Read entries in a directory	<dirent.h>
closedir()	Close the directory stream	<dirent.h>
rewinddir()	Reset directory stream position	<dirent.h>
Would you like me to combine all these examples into one single C file (menu-based directory operations program)? Itâ€™s perfect for OS lab practicals.

You said:
ftw  seek telldirstat dircntl
ChatGPT said:
Excellent â€” youâ€™re asking about advanced directory-related system calls and functions in UNIX/Linux beyond the basic ones like opendir() and readdir().
Letâ€™s go through each of them in detail:

âš™ï¸ Advanced Directory and File Tree System Calls
These functions give more control and automation for directory traversal, directory stream manipulation, and file system inspection.

1. ftw() â€“ File Tree Walk
Header:

#include <ftw.h>
Syntax:

int ftw(const char *dirpath, int (*fn)(const char *fpath, const struct stat *sb, int typeflag), int nopenfd);
Description:

Walks through a directory tree recursively starting from dirpath.

For each file or directory found, the function fn() is called.

It provides information like file type and attributes through a struct stat.

Arguments:

dirpath: starting directory path

fn: callback function executed for every file/directory

nopenfd: max number of file descriptors that can be open simultaneously

Common typeflag values:

Value	Meaning
FTW_F	Regular file
FTW_D	Directory
FTW_DNR	Directory not readable
FTW_NS	stat() failed
Example:

#include <stdio.h>
#include <ftw.h>
#include <stdlib.h>

int display_info(const char *fpath, const struct stat *sb, int typeflag) {
    printf("%s\n", fpath);
    return 0;
}

int main() {
    if (ftw(".", display_info, 10) == -1) {
        perror("ftw");
        exit(EXIT_FAILURE);
    }
    return 0;
}
ğŸ“˜ Purpose: Recursively list files and directories â€” like ls -R.

2. seekdir() â€“ Set Position in Directory Stream
Header:

#include <dirent.h>
Syntax:

void seekdir(DIR *dirp, long loc);
Description:
Moves the directory stream position to a specific location previously obtained by telldir().

Usage:

Used together with telldir() for random access in directories.

Example:

#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *d = opendir(".");
    struct dirent *dir;
    long pos;

    dir = readdir(d);
    printf("First: %s\n", dir->d_name);
    pos = telldir(d);   // store current position

    dir = readdir(d);
    printf("Second: %s\n", dir->d_name);

    seekdir(d, pos);    // move back to previous position
    dir = readdir(d);
    printf("After seekdir: %s\n", dir->d_name);

    closedir(d);
    return 0;
}
ğŸ“˜ Purpose: Jump to a known position in a directory stream.

3. telldir() â€“ Get Current Position in Directory Stream
Header:

#include <dirent.h>
Syntax:

long telldir(DIR *dirp);
Description:
Returns the current location within the directory stream dirp.
Used with seekdir() to restore a previous position.

Example: (included above with seekdir())

ğŸ“˜ Purpose: Record the current reading position in a directory stream.

4. fstat() â€“ Get File Status Using File Descriptor
Header:

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
Syntax:

int fstat(int fd, struct stat *statbuf);
Description:
Obtains file information (permissions, size, etc.) using a file descriptor rather than filename.

Example:

#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd;
    struct stat info;

    fd = open("test.txt", O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    if (fstat(fd, &info) == 0)
        printf("File size: %ld bytes\n", info.st_size);
    else
        perror("fstat");

    close(fd);
    return 0;
}
ğŸ“˜ Purpose: Get metadata about a file already opened.

5. dirfd() â€“ Get File Descriptor of an Open Directory Stream
Header:

#include <dirent.h>
Syntax:

int dirfd(DIR *dirp);
Description:
Returns the file descriptor associated with an open directory stream (DIR *).
Useful when you want to call fstat() or fcntl() on an open directory.

Example:

#include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>

int main() {
    DIR *d = opendir(".");
    if (!d) return 1;

    int fd = dirfd(d);
    struct stat info;

    if (fstat(fd, &info) == 0)
        printf("Directory inode: %ld\n", info.st_ino);
    else
        perror("fstat");

    closedir(d);
    return 0;
}
ğŸ“˜ Purpose: Bridge between directory streams and file descriptors.

6. fcntl() â€“ File Control Operations
Header:

#include <fcntl.h>
#include <unistd.h>
Syntax:

int fcntl(int fd, int cmd, ... /* arg */ );
Description:
Performs control operations on an open file descriptor (including those from directories via dirfd()).

Common Uses:

Get/set file descriptor flags

Set file locking (e.g., F_SETLK, F_GETFD)

Example:

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("test.txt", O_RDONLY);
    if (fd < 0) { perror("open"); return 1; }

    int flags = fcntl(fd, F_GETFL);
    if (flags == -1) perror("fcntl");
    else printf("File access mode: %d\n", flags & O_ACCMODE);

    close(fd);
    return 0;
}
ğŸ“˜ Purpose: Advanced file/directory descriptor manipulation (flags, locks).

ğŸ§¾ Summary Table
Function	Purpose	Header File
ftw()	Recursively walk file tree	<ftw.h>
seekdir()	Set directory stream position	<dirent.h>
telldir()	Get current directory position	<dirent.h>
fstat()	Get file status via descriptor	<sys/stat.h>
dirfd()	Get file descriptor of directory stream	<dirent.h>
fcntl()	Control file descriptor behavior	<fcntl.h>
Would you like me to give you one combined program that demonstrates all these (ftw, telldir, seekdir, dirfd, fstat) together in a single menu-based format for your OS lab submission?

You said:
combining all functions fully organised
ChatGPT said:
Perfect ğŸ‘ â€” below is a fully organized, single C program combining all the major directory-related system calls and functions, including both basic and advanced ones (mkdir, rmdir, chdir, getcwd, opendir, readdir, closedir, ftw, telldir, seekdir, dirfd, fstat, and fcntl).

Itâ€™s written in a menu-based format, suitable for OS lab practicals or Viva demonstrations.
The program is modular, well-commented, and easy to run on any Linux system.

ğŸ§© Full Program: Directory Operations in UNIX
/*
 ============================================================================
 Name        : directory_system_calls.c
 Author      : Kathir Kalidass
 Description : Combined demonstration of Directory related System Calls in UNIX
 ============================================================================
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <ftw.h>
#include <string.h>
#include <errno.h>

/* ---------- Function Declarations ---------- */
void create_directory();
void remove_directory();
void change_directory();
void print_working_directory();
void list_directory();
void ftw_display();
void telldir_seekdir_demo();
void dirfd_fstat_demo();
void pause_and_clear();

/* ---------- Callback for ftw ---------- */
int display_info(const char *fpath, const struct stat *sb, int typeflag) {
    printf("%-60s", fpath);
    switch (typeflag) {
        case FTW_F:  printf(" [FILE]\n"); break;
        case FTW_D:  printf(" [DIR]\n"); break;
        case FTW_DNR:printf(" [DIR-NOT READABLE]\n"); break;
        case FTW_NS: printf(" [STAT FAILED]\n"); break;
        default:     printf(" [UNKNOWN]\n"); break;
    }
    return 0;
}

/* ---------- Function Definitions ---------- */

void create_directory() {
    char name[100];
    printf("Enter directory name to create: ");
    scanf("%s", name);

    if (mkdir(name, 0777) == 0)
        printf("âœ… Directory '%s' created successfully.\n", name);
    else
        perror("mkdir");
}

void remove_directory() {
    char name[100];
    printf("Enter directory name to remove: ");
    scanf("%s", name);

    if (rmdir(name) == 0)
        printf("âœ… Directory '%s' removed successfully.\n", name);
    else
        perror("rmdir");
}

void change_directory() {
    char path[200];
    printf("Enter path to change directory: ");
    scanf("%s", path);

    if (chdir(path) == 0)
        printf("âœ… Changed to directory: %s\n", path);
    else
        perror("chdir");
}

void print_working_directory() {
    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) != NULL)
        printf("ğŸ“ Current working directory: %s\n", cwd);
    else
        perror("getcwd");
}

void list_directory() {
    DIR *d;
    struct dirent *dir;
    char path[200];
    printf("Enter directory path to list: ");
    scanf("%s", path);

    d = opendir(path);
    if (d == NULL) {
        perror("opendir");
        return;
    }

    printf("\nContents of directory '%s':\n", path);
    while ((dir = readdir(d)) != NULL)
        printf(" - %s\n", dir->d_name);
    closedir(d);
}

void ftw_display() {
    char path[200];
    printf("Enter directory path for recursive display: ");
    scanf("%s", path);

    printf("\nğŸ“‚ Recursive directory listing using ftw():\n");
    if (ftw(path, display_info, 10) == -1)
        perror("ftw");
}

void telldir_seekdir_demo() {
    DIR *d;
    struct dirent *dir;
    d = opendir(".");

    if (!d) {
        perror("opendir");
        return;
    }

    printf("Reading first entry...\n");
    dir = readdir(d);
    printf("Entry: %s\n", dir->d_name);

    long pos = telldir(d);
    printf("Position after first entry: %ld\n", pos);

    dir = readdir(d);
    printf("Next entry: %s\n", dir->d_name);

    printf("Rewinding back using seekdir()...\n");
    seekdir(d, pos);

    dir = readdir(d);
    printf("After seekdir(): %s\n", dir->d_name);

    closedir(d);
}

void dirfd_fstat_demo() {
    DIR *d = opendir(".");
    if (!d) {
        perror("opendir");
        return;
    }

    int fd = dirfd(d);
    struct stat info;

    if (fstat(fd, &info) == 0) {
        printf("Directory inode number: %ld\n", info.st_ino);
        printf("Number of links: %ld\n", info.st_nlink);
        printf("Size: %ld bytes\n", info.st_size);
    } else {
        perror("fstat");
    }

    int flags = fcntl(fd, F_GETFD);
    if (flags != -1)
        printf("fcntl() FD flags: %d\n", flags);
    else
        perror("fcntl");

    closedir(d);
}

void pause_and_clear() {
    printf("\nPress ENTER to continue...");
    getchar(); getchar();
    system("clear");
}

/* ---------- Main Menu ---------- */
int main() {
    int choice;
    while (1) {
        printf("====================================================\n");
        printf("       UNIX DIRECTORY RELATED SYSTEM CALLS MENU     \n");
        printf("====================================================\n");
        printf(" 1. Create Directory (mkdir)\n");
        printf(" 2. Remove Directory (rmdir)\n");
        printf(" 3. Change Directory (chdir)\n");
        printf(" 4. Print Working Directory (getcwd)\n");
        printf(" 5. List Directory Contents (opendir, readdir, closedir)\n");
        printf(" 6. Recursive File Tree Walk (ftw)\n");
        printf(" 7. Demonstrate telldir() and seekdir()\n");
        printf(" 8. Demonstrate dirfd(), fstat(), and fcntl()\n");
        printf(" 9. Exit\n");
        printf("----------------------------------------------------\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1: create_directory(); break;
            case 2: remove_directory(); break;
            case 3: change_directory(); break;
            case 4: print_working_directory(); break;
            case 5: list_directory(); break;
            case 6: ftw_display(); break;
            case 7: telldir_seekdir_demo(); break;
            case 8: dirfd_fstat_demo(); break;
            case 9: printf("Exiting...\n"); exit(0);
            default: printf("Invalid choice!\n"); break;
        }
        pause_and_clear();
    }
    return 0;
}
ğŸ§  Concepts Demonstrated
Concept	System Calls / Functions Used
Create / Remove Directory	mkdir(), rmdir()
Change / Print Directory	chdir(), getcwd()
List Directory	opendir(), readdir(), closedir()
Recursive Tree Listing	ftw()
Stream Position Control	telldir(), seekdir()
Directory File Descriptor Info	dirfd(), fstat()
Descriptor Flags	fcntl()
ğŸ§ª Compilation & Execution
gcc directory_system_calls.c -o dircalls -Wall
./dircalls
Would you like me to provide a simplified version (for classroom demo, with fewer menus) or keep this full OS lab version with all functions and comments as final for your submission?

You said:
get a name string from user check if it is a directory name or a file name if it is a directory then print all file names with all sub directories and its file too and also print contents of the file  

if it is a file then print all ci=ontents of file  and its no of lines characters word vowels consonants letters count
ChatGPT said:
Excellent practical question, Kathir ğŸ‘ â€” this combines file handling, directory traversal, and text analysis into one rich OS lab program.

Below is a complete, modular, and well-documented C program that does exactly what you asked:

ğŸ§© Program Description
Get a path (file or directory name) from the user.

If it is a file:

Print all file contents.

Count and display:

Number of lines

Number of words

Number of characters

Number of letters

Number of vowels

Number of consonants

If it is a directory:

Recursively print all files and subdirectories (like ls -R).

For each file found, print its contents.

âœ… Full C Program
/*
 ============================================================================
 Name        : file_dir_analysis.c
 Author      : Kathir Kalidass
 Description : Check if input path is a file or directory
               - If file â†’ print contents + counts
               - If directory â†’ recursively print all files & subdirectories
                 and also display file contents
 ============================================================================
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

/* -------- Function Declarations -------- */
void analyze_file(const char *filepath);
void explore_directory(const char *dirpath, int level);

/* -------- Function to Analyze File Contents -------- */
void analyze_file(const char *filepath) {
    FILE *fp = fopen(filepath, "r");
    if (!fp) {
        perror("fopen");
        return;
    }

    int ch, lines = 0, words = 0, chars = 0, vowels = 0, consonants = 0, letters = 0;
    int in_word = 0;

    printf("\n-------------------------------\n");
    printf("ğŸ“„ File: %s\n", filepath);
    printf("-------------------------------\n");

    // Print contents and count statistics
    while ((ch = fgetc(fp)) != EOF) {
        putchar(ch);
        chars++;

        if (ch == '\n')
            lines++;

        if (isalpha(ch)) {
            letters++;
            char lower = tolower(ch);
            if (lower == 'a' || lower == 'e' || lower == 'i' || lower == 'o' || lower == 'u')
                vowels++;
            else
                consonants++;
        }

        if (isspace(ch))
            in_word = 0;
        else if (!in_word) {
            in_word = 1;
            words++;
        }
    }

    printf("\n---------------------------------------\n");
    printf("File Statistics for: %s\n", filepath);
    printf("---------------------------------------\n");
    printf("Lines       : %d\n", lines);
    printf("Words       : %d\n", words);
    printf("Characters  : %d\n", chars);
    printf("Letters     : %d\n", letters);
    printf("Vowels      : %d\n", vowels);
    printf("Consonants  : %d\n", consonants);
    printf("---------------------------------------\n");

    fclose(fp);
}

/* -------- Recursive Directory Traversal -------- */
void explore_directory(const char *dirpath, int level) {
    DIR *dir;
    struct dirent *entry;
    struct stat info;
    char path[1024];

    dir = opendir(dirpath);
    if (!dir) {
        perror("opendir");
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        // Skip "." and ".."
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", dirpath, entry->d_name);
        if (stat(path, &info) == -1) {
            perror("stat");
            continue;
        }

        // Print indentation based on depth level
        for (int i = 0; i < level; i++)
            printf("  ");

        if (S_ISDIR(info.st_mode)) {
            printf("ğŸ“ Directory: %s\n", path);
            explore_directory(path, level + 1);
        } else if (S_ISREG(info.st_mode)) {
            printf("ğŸ“„ File: %s\n", path);
            analyze_file(path);
        }
    }
    closedir(dir);
}

/* -------- Main Function -------- */
int main() {
    char path[512];
    struct stat info;

    printf("Enter a file or directory name: ");
    scanf("%s", path);

    if (stat(path, &info) != 0) {
        perror("stat");
        return 1;
    }

    if (S_ISDIR(info.st_mode)) {
        printf("\nâœ… '%s' is a directory.\n", path);
        explore_directory(path, 0);
    } else if (S_ISREG(info.st_mode)) {
        printf("\nâœ… '%s' is a file.\n", path);
        analyze_file(path);
    } else {
        printf("\nâš ï¸ '%s' is neither a regular file nor a directory.\n", path);
    }

    return 0;
}
ğŸ§  Explanation
Part	Description
stat()	Used to check whether the path is a file or directory
S_ISDIR() / S_ISREG()	Macros to test file type
explore_directory()	Recursively lists directories and calls analyze_file() for each file
analyze_file()	Opens file, prints contents, and counts lines, words, characters, vowels, consonants, letters
ğŸ§ª Compilation & Execution
gcc file_dir_analysis.c -o filedir
./filedir
Example Input/Output:
Enter a file or directory name: testdir

âœ… 'testdir' is a directory.
ğŸ“ Directory: testdir
  ğŸ“„ File: testdir/file1.txt
  (file contents printed)
  ğŸ“ Directory: testdir/subdir
    ğŸ“„ File: testdir/subdir/file2.txt
    (file contents printed)
Or:

Enter a file or directory name: notes.txt

âœ… 'notes.txt' is a file.

(File contents printed)
---------------------------------------
File Statistics:
Lines       : 12
Words       : 85
Characters  : 540
Letters     : 420
Vowels      : 180
Consonants  : 240
---------------------------------------
Would you like me to extend this version to save the output (directory structure + file stats) into a separate report file (e.g., output.txt) as well? That would make it perfect for submission and verification.

You said:
get a string if it is a directoy/file then locate recursively in all its sudeirestores present to find the possition
ChatGPT said:
Got it ğŸ‘ â€” you want a C program that:

Gets a name (string) from the user.

Recursively searches all directories and subdirectories from the current working directory to locate the file or directory matching that name.

Prints the full path (absolute path) if found.

Displays whether itâ€™s a file or a directory.

Hereâ€™s the complete and organized C program for that ğŸ‘‡

âœ… Program: locate.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

// Function to recursively search for the file or directory
void search(const char *base_path, const char *target_name) {
    struct dirent *entry;
    DIR *dir = opendir(base_path);

    if (dir == NULL)
        return;

    while ((entry = readdir(dir)) != NULL) {
        // Skip "." and ".."
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        char path[1024];
        snprintf(path, sizeof(path), "%s/%s", base_path, entry->d_name);

        // Check if the name matches
        if (strcmp(entry->d_name, target_name) == 0) {
            struct stat st;
            if (stat(path, &st) == 0) {
                printf("\nFound: %s\n", path);
                if (S_ISDIR(st.st_mode))
                    printf("Type: Directory\n");
                else if (S_ISREG(st.st_mode))
                    printf("Type: File\n");
            }
        }

        // Recurse into directories
        struct stat st;
        if (stat(path, &st) == 0 && S_ISDIR(st.st_mode)) {
            search(path, target_name);
        }
    }

    closedir(dir);
}

int main() {
    char name[100];
    char start_path[1024];

    // Get current working directory
    getcwd(start_path, sizeof(start_path));

    printf("Enter the file or directory name to search: ");
    scanf("%s", name);

    printf("\nSearching for \"%s\" starting from: %s\n", name, start_path);
    search(start_path, name);

    printf("\nSearch completed.\n");
    return 0;
}
ğŸ§  How it works
Uses opendir(), readdir(), and closedir() for directory traversal.

Uses stat() to determine whether a found entry is a file or directory.

Uses recursion to explore all subdirectories.

Prints the absolute path for every match found.

ğŸ§ª Example Output
Enter the file or directory name to search: main.c

Searching for "main.c" starting from: /home/kathir/projects

Found: /home/kathir/projects/test/main.c
Type: File

Found: /home/kathir/projects/src/main.c
Type: File

Search completed.
Would you like me to extend this so that:

If the found item is a file â†’ print file contents + counts (lines, words, vowels, etc.)

If the found item is a directory â†’ list all files inside it (recursively)?

That would turn this into a complete "search + inspect" tool.

You said:
ckeck if a file/directory present in this directory only not in subdirectory
ChatGPT said:
Perfect âœ… â€” you want a C program that checks whether a given name (file or directory) exists in the current directory only, not recursively in subdirectories.

Hereâ€™s the complete organized C program for that:

âœ… Program: check_in_current_dir.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    char name[100];
    struct dirent *entry;
    DIR *dir;
    struct stat st;
    char path[1024];
    int found = 0;

    // Get current working directory
    getcwd(path, sizeof(path));

    printf("Enter the file or directory name to check: ");
    scanf("%s", name);

    dir = opendir(path);
    if (dir == NULL) {
        perror("Unable to open current directory");
        return 1;
    }

    // Read entries in current directory only
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, name) == 0) {
            snprintf(path, sizeof(path), "%s/%s", ".", entry->d_name);
            if (stat(path, &st) == 0) {
                printf("\nFound: %s\n", entry->d_name);
                if (S_ISDIR(st.st_mode))
                    printf("Type: Directory\n");
                else if (S_ISREG(st.st_mode))
                    printf("Type: File\n");
                found = 1;
                break;
            }
        }
    }

    closedir(dir);

    if (!found)
        printf("\n'%s' not found in current directory.\n", name);

    return 0;
}
ğŸ§  Explanation
Uses opendir() to open the current directory (.).

Reads each entry using readdir().

Compares the input name with each directory entryâ€™s name.

Uses stat() to determine if itâ€™s a file or directory.

Does not recurse into subdirectories.

ğŸ§ª Example Output
Case 1 â€“ File found

Enter the file or directory name to check: main.c

Found: main.c
Type: File
Case 2 â€“ Directory found

Enter the file or directory name to check: src

Found: src
Type: Directory
Case 3 â€“ Not found

Enter the file or directory name to check: notes.txt

'notes.txt' not found in current directory.
Would you like me to extend this version so that if the item is found and is a file, it also prints file contents + line/word/character counts?

You said:
a program that gets a directory name only then it will make sub directories in that directory such that it will make if file1.c  to move to c_files  file2.txt to move to txt_files  like this from extensions for now with no extension files remain in that same itself
ChatGPT said:
Excellent ğŸ‘ â€” you want a C program that:

Takes a directory name as input.

Reads all files inside that directory (not subdirectories).

Groups files based on their file extensions (like .c, .txt, .jpg, etc.).

Creates subdirectories named <extension>_files (like c_files, txt_files) inside the given directory.

Moves each file into its respective subdirectory.

Files without extensions remain in the same directory.

âœ… Full C Program: organize_by_extension.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

void organize_files(const char *dir_name) {
    DIR *dir;
    struct dirent *entry;
    char old_path[512], new_dir[512], new_path[512];
    struct stat st;

    dir = opendir(dir_name);
    if (!dir) {
        perror("Unable to open directory");
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        // Skip . and ..
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(old_path, sizeof(old_path), "%s/%s", dir_name, entry->d_name);

        // Check if it's a file
        if (stat(old_path, &st) == 0 && S_ISREG(st.st_mode)) {
            // Find the last '.' in filename
            char *dot = strrchr(entry->d_name, '.');

            if (dot != NULL) {
                // Get extension (skip '.')
                char extension[100];
                strcpy(extension, dot + 1);

                // Create new directory name like "<ext>_files"
                snprintf(new_dir, sizeof(new_dir), "%s/%s_files", dir_name, extension);

                // Create directory if not exists
                mkdir(new_dir, 0755);

                // Construct new file path
                snprintf(new_path, sizeof(new_path), "%s/%s", new_dir, entry->d_name);

                // Move file to new directory
                if (rename(old_path, new_path) == 0)
                    printf("Moved: %s -> %s\n", entry->d_name, new_dir);
                else
                    perror("Error moving file");
            } else {
                // File with no extension remains in same folder
                printf("No extension: %s (kept in same directory)\n", entry->d_name);
            }
        }
    }

    closedir(dir);
}

int main() {
    char dirname[256];
    printf("Enter the directory name: ");
    scanf("%s", dirname);

    organize_files(dirname);

    printf("\nFile organization completed.\n");
    return 0;
}
ğŸ§  How it Works
Opens the given directory using opendir().

Iterates through all files with readdir().

Uses stat() to ensure itâ€™s a regular file, not a folder.

Extracts the file extension using strrchr().

Creates a subdirectory <extension>_files if it doesnâ€™t already exist.

Moves the file using rename().

Files with no extensions stay in place.

ğŸ§ª Example
Before:

myfolder/
 â”œâ”€â”€ file1.c
 â”œâ”€â”€ file2.txt
 â”œâ”€â”€ report.txt
 â”œâ”€â”€ notes
 â””â”€â”€ main.c
After running program:

myfolder/
 â”œâ”€â”€ c_files/
 â”‚    â”œâ”€â”€ file1.c
 â”‚    â””â”€â”€ main.c
 â”œâ”€â”€ txt_files/
 â”‚    â”œâ”€â”€ file2.txt
 â”‚    â””â”€â”€ report.txt
 â””â”€â”€ notes
Would you like to extend this version so that it also processes subdirectories recursively (organizing files in subfolders too)?

You said:
go on
ChatGPT said:
Perfect ğŸ”¥ â€” letâ€™s now extend it into a recursive version that organizes all files in the given directory and all its subdirectories.

So now, it will:
âœ… Traverse directories recursively.
âœ… Create <extension>_files subfolders only inside the root directory you entered.
âœ… Move all discovered files (even deep inside subfolders) to their proper <ext>_files folder.
âœ… Leave files with no extension in their original place.

âœ… Full Recursive C Program: organize_recursive.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

char base_dir[512]; // store the root directory

void organize_files(const char *dir_name) {
    DIR *dir;
    struct dirent *entry;
    char path[1024], new_dir[1024], new_path[1024];
    struct stat st;

    dir = opendir(dir_name);
    if (!dir) {
        perror("Unable to open directory");
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        // Skip . and ..
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", dir_name, entry->d_name);

        if (stat(path, &st) == 0) {
            if (S_ISDIR(st.st_mode)) {
                // Recurse into subdirectory
                organize_files(path);
            } else if (S_ISREG(st.st_mode)) {
                // File found - get extension
                char *dot = strrchr(entry->d_name, '.');
                if (dot != NULL) {
                    char ext[100];
                    strcpy(ext, dot + 1);

                    // Create directory in base_dir (root)
                    snprintf(new_dir, sizeof(new_dir), "%s/%s_files", base_dir, ext);
                    mkdir(new_dir, 0755);

                    // Construct new path
                    snprintf(new_path, sizeof(new_path), "%s/%s", new_dir, entry->d_name);

                    // Move file
                    if (rename(path, new_path) == 0)
                        printf("Moved: %s -> %s\n", path, new_dir);
                    else
                        perror("Error moving file");
                } else {
                    // File without extension -> leave it
                    printf("No extension: %s (kept in %s)\n", entry->d_name, dir_name);
                }
            }
        }
    }

    closedir(dir);
}

int main() {
    printf("Enter the root directory name: ");
    scanf("%s", base_dir);

    // Remove trailing slash if present
    int len = strlen(base_dir);
    if (base_dir[len - 1] == '/')
        base_dir[len - 1] = '\0';

    printf("\nOrganizing files recursively under: %s\n\n", base_dir);
    organize_files(base_dir);

    printf("\nâœ… File organization completed successfully.\n");
    return 0;
}
ğŸ§  Logic Summary
Uses recursion (organize_files()) to explore all directories.

For every regular file:

Gets its extension using strrchr().

Creates <extension>_files folder in the base directory only.

Moves file there with rename().

Files with no extension are not moved.

ğŸ§ª Example
Before:

project/
 â”œâ”€â”€ src/
 â”‚    â”œâ”€â”€ main.c
 â”‚    â””â”€â”€ util.c
 â”œâ”€â”€ docs/
 â”‚    â””â”€â”€ readme.txt
 â”œâ”€â”€ data.csv
 â”œâ”€â”€ report.txt
 â””â”€â”€ LICENSE
After running:

project/
 â”œâ”€â”€ c_files/
 â”‚    â”œâ”€â”€ main.c
 â”‚    â””â”€â”€ util.c
 â”œâ”€â”€ txt_files/
 â”‚    â””â”€â”€ readme.txt
 â”œâ”€â”€ csv_files/
 â”‚    â””â”€â”€ data.csv
 â”œâ”€â”€ LICENSE
 â”œâ”€â”€ docs/        (now empty)
 â””â”€â”€ src/         (now empty)
Would you like me to add one more feature â€”
ğŸ‘‰ print a summary at the end (like how many files moved per extension)?
That makes it look like a mini file organizer tool.




No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.
