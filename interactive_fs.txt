Interactive File-System Syscalls â€” Menu-driven C Program (reads from user, not argv)
====================================================================================

Build
- Use Linux or WSL for POSIX syscalls.
- Save the code below to interactive_fs.c and compile:
  gcc interactive_fs.c -o interactive_fs

Run
- ./interactive_fs
- Follow on-screen prompts. Inputs are read from the user (no command-line args).

Code
/* interactive_fs.c */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>
#include <errno.h>

#define BUF_SZ 8192

static void trim_newline(char *s) {
    if (!s) return;
    size_t n = strlen(s);
    if (n && (s[n-1] == '\n')) s[n-1] = '\0';
}

static int prompt_line(const char *msg, char *out, size_t outsz) {
    fputs(msg, stdout);
    fflush(stdout);
    if (!fgets(out, (int)outsz, stdin)) return 0;
    trim_newline(out);
    return 1;
}

static long long prompt_ll(const char *msg, long long defval) {
    char buf[256];
    if (!prompt_line(msg, buf, sizeof(buf))) return defval;
    if (buf[0] == '\0') return defval;
    char *end = NULL;
    long long v = strtoll(buf, &end, 10);
    if (end == buf) return defval;
    return v;
}

static int write_all(int fd, const void *buf, size_t len) {
    const char *p = (const char*)buf;
    size_t off = 0;
    while (off < len) {
        ssize_t w = write(fd, p + off, len - off);
        if (w < 0) {
            if (errno == EINTR) continue;
            perror("write");
            return -1;
        }
        off += (size_t)w;
    }
    return 0;
}

static void do_create_write(void) {
    char path[1024];
    if (!prompt_line("Enter output filename [student.txt]: ", path, sizeof(path))) return;
    if (path[0] == '\0') strcpy(path, "student.txt");

    int fd = open(path, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return; }

    char name[256], reg[256], dept[256];
    if (!prompt_line("Enter Name: ", name, sizeof(name))) { close(fd); return; }
    if (!prompt_line("Enter Register Number: ", reg, sizeof(reg))) { close(fd); return; }
    if (!prompt_line("Enter Department: ", dept, sizeof(dept))) { close(fd); return; }

    char buf[1024];
    int len = snprintf(buf, sizeof(buf), "Name: %s\nReg: %s\nDept: %s\n", name, reg, dept);
    if (len < 0) { perror("snprintf"); close(fd); return; }
    if (write_all(fd, buf, (size_t)len) < 0) { close(fd); return; }

    close(fd);
    printf("Wrote details to %s\n", path);
}

static void do_read_file(void) {
    char path[1024];
    if (!prompt_line("Enter filename to read: ", path, sizeof(path))) return;
    int fd = open(path, O_RDONLY);
    if (fd < 0) { perror("open"); return; }
    char buf[BUF_SZ];
    ssize_t r;
    while ((r = read(fd, buf, sizeof(buf))) > 0) {
        if (write_all(STDOUT_FILENO, buf, (size_t)r) < 0) { close(fd); return; }
    }
    if (r < 0) perror("read");
    close(fd);
}

static void do_copy_file(int append) {
    char src[1024], dst[1024];
    if (!prompt_line("Source file: ", src, sizeof(src))) return;
    if (!prompt_line("Destination file: ", dst, sizeof(dst))) return;
    int in = open(src, O_RDONLY);
    if (in < 0) { perror("open src"); return; }
    int flags = append ? (O_WRONLY | O_APPEND | O_CREAT) : (O_WRONLY | O_CREAT | O_TRUNC);
    int out = open(dst, flags, 0644);
    if (out < 0) { perror("open dst"); close(in); return; }

    char buf[BUF_SZ];
    ssize_t r;
    while ((r = read(in, buf, sizeof(buf))) > 0) {
        if (write_all(out, buf, (size_t)r) < 0) { close(in); close(out); return; }
    }
    if (r < 0) perror("read");
    close(in); close(out);
}

static void do_lseek_demo(void) {
    char path[1024];
    if (!prompt_line("File for lseek demo: ", path, sizeof(path))) return;
    int fd = open(path, O_RDONLY);
    if (fd < 0) { perror("open"); return; }
    off_t end = lseek(fd, 0, SEEK_END);
    if (end == (off_t)-1) { perror("lseek end"); close(fd); return; }
    printf("File size: %lld bytes\n", (long long)end);

    long long off = prompt_ll("Offset [5]: ", 5);
    long long cnt = prompt_ll("Count [32]: ", 32);
    if (lseek(fd, (off_t)off, SEEK_SET) == (off_t)-1) { perror("lseek set"); close(fd); return; }

    char *buf = (char*)malloc((size_t)cnt + 1);
    if (!buf) { perror("malloc"); close(fd); return; }
    ssize_t r = read(fd, buf, (size_t)cnt);
    if (r < 0) { perror("read"); free(buf); close(fd); return; }
    buf[r] = '\0';
    printf("Data at offset %lld (up to %lld bytes):\n%.*s\n", off, cnt, (int)r, buf);
    free(buf);
    close(fd);
}

static void mode_to_rwx(mode_t m, char out[11]) {
    const char t = S_ISDIR(m)?'d':S_ISLNK(m)?'l':S_ISCHR(m)?'c':S_ISBLK(m)?'b':S_ISSOCK(m)?'s':S_ISFIFO(m)?'p':'-';
    out[0]=t;
    out[1]=(m&S_IRUSR)?'r':'-'; out[2]=(m&S_IWUSR)?'w':'-'; out[3]=(m&S_IXUSR)?'x':'-';
    out[4]=(m&S_IRGRP)?'r':'-'; out[5]=(m&S_IWGRP)?'w':'-'; out[6]=(m&S_IXGRP)?'x':'-';
    out[7]=(m&S_IROTH)?'r':'-'; out[8]=(m&S_IWOTH)?'w':'-'; out[9]=(m&S_IXOTH)?'x':'-';
    out[10]='\0';
}

static void do_stat_info(void) {
    char path[1024];
    if (!prompt_line("File for stat(): ", path, sizeof(path))) return;
    struct stat st;
    if (stat(path, &st) < 0) { perror("stat"); return; }
    char perm[11]; mode_to_rwx(st.st_mode, perm);
    struct passwd *pw = getpwuid(st.st_uid);
    struct group  *gr = getgrgid(st.st_gid);
    printf("Size: %lld bytes\n", (long long)st.st_size);
    printf("Perms: %s (octal %04o)\n", perm, st.st_mode & 07777);
    printf("Owner: %s (%u)\n", pw?pw->pw_name:"?", st.st_uid);
    printf("Group: %s (%u)\n", gr?gr->gr_name:"?", st.st_gid);
    printf("Inode: %llu\n", (unsigned long long)st.st_ino);
}

static void do_dup_demo(void) {
    char path[1024];
    if (!prompt_line("File for dup/dup2 demo [dup_demo.txt]: ", path, sizeof(path))) return;
    if (path[0] == '\0') strcpy(path, "dup_demo.txt");
    int fd = open(path, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return; }

    int fd2 = dup(fd);
    if (fd2 < 0) { perror("dup"); close(fd); return; }
    const char *m1 = "Hello via fd\n";
    const char *m2 = "Hello via dup(fd)\n";
    write_all(fd,  m1, strlen(m1));
    write_all(fd2, m2, strlen(m2));

    int saved_out = dup(STDOUT_FILENO);
    if (saved_out < 0) { perror("dup stdout"); }
    if (dup2(fd, STDOUT_FILENO) < 0) { perror("dup2"); }
    printf("Hello via stdout after dup2\n");
    fflush(stdout);
    if (saved_out >= 0) {
        if (dup2(saved_out, STDOUT_FILENO) < 0) perror("restore stdout");
        close(saved_out);
    }
    close(fd2);
    close(fd);
    printf("Wrote messages to %s\n", path);
}

static void do_unlink_file(void) {
    char path[1024];
    if (!prompt_line("File to delete: ", path, sizeof(path))) return;
    if (unlink(path) < 0) { perror("unlink"); return; }
    printf("Deleted: %s\n", path);
}

static void do_dir_ops(void) {
    char dir[256];
    if (!prompt_line("Directory name [mydir]: ", dir, sizeof(dir))) return;
    if (dir[0] == '\0') strcpy(dir, "mydir");

    if (mkdir(dir, 0755) < 0) { perror("mkdir"); return; }
    printf("Created dir: %s\n", dir);

    char cwd[1024];
    if (!getcwd(cwd, sizeof(cwd))) { perror("getcwd"); return; }
    printf("CWD before chdir: %s\n", cwd);

    if (chdir(dir) < 0) { perror("chdir"); return; }
    if (!getcwd(cwd, sizeof(cwd))) { perror("getcwd"); return; }
    printf("CWD inside dir: %s\n", cwd);

    if (chdir("..") < 0) { perror("chdir .."); return; }
    if (rmdir(dir) < 0) { perror("rmdir"); return; }
    printf("Removed dir: %s\n", dir);
}

static void do_write_multiline(void) {
    char path[1024];
    if (!prompt_line("Output file [notes.txt]: ", path, sizeof(path))) return;
    if (path[0] == '\0') strcpy(path, "notes.txt");

    int fd = open(path, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return; }
    printf("Enter text. End with a single line containing EOF.\n");
    char line[BUF_SZ];
    while (fgets(line, sizeof(line), stdin)) {
        if (strcmp(line, "EOF\n") == 0 || strcmp(line, "EOF\r\n") == 0) break;
        if (write_all(fd, line, strlen(line)) < 0) { close(fd); return; }
    }
    close(fd);
    printf("Saved to %s\n", path);
}

int main(void) {
    for (;;) {
        puts("\n--- Interactive File-System Syscalls Demo ---");
        puts("1) Create & write student details");
        puts("2) Read a file");
        puts("3) Copy file");
        puts("4) Append file to another");
        puts("5) lseek demo (offset read)");
        puts("6) stat info (size/perms/owner)");
        puts("7) dup/dup2 demo (redirect stdout)");
        puts("8) Delete (unlink) a file");
        puts("9) Directory ops (mkdir/chdir/rmdir)");
        puts("10) Write multi-line text (EOF to end)");
        puts("0) Exit");

        long long choice = prompt_ll("Enter choice: ", -1);
        switch (choice) {
            case 1:  do_create_write(); break;
            case 2:  do_read_file(); break;
            case 3:  do_copy_file(0); break;
            case 4:  do_copy_file(1); break;
            case 5:  do_lseek_demo(); break;
            case 6:  do_stat_info(); break;
            case 7:  do_dup_demo(); break;
            case 8:  do_unlink_file(); break;
            case 9:  do_dir_ops(); break;
            case 10: do_write_multiline(); break;
            case 0:  puts("Bye!"); return 0;
            default: puts("Invalid choice. Try again."); break;
        }
    }
}
